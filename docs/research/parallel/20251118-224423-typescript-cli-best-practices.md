# TypeScript CLI Best Practices

**Date:** 2025-11-18
**Objective:** best practises for typescript CLIs

## Executive Summary

TypeScript CLI development benefits from type-safe argument parsing, structured error handling, modular architecture, and comprehensive testing. Popular frameworks like **Commander**, **oclif**, and **cmd-ts** provide different approaches to building maintainable CLI tools, with type safety and validation being critical for production-ready applications.

## Key Findings

### Framework Selection

- **Commander**: High-level, popular CLI parser with autogenerated `--help`, validation, and simple flag/option support. However, lacks type safety (arguments typed as `any`).
- **oclif**: Full-featured CLI framework with built-in testing, documentation generation, and plugin system. Ideal for complex CLI applications.
- **cmd-ts**: Type-driven parser inspired by Rust's `structopt`, providing **full type safety** at compile-time and runtime. Parsing/validation handled by the argument parser itself.
- **yargs**: Alternative parser with similar features to Commander.

### Argument Parsing & Type Safety

- **Type-first approach**: Use libraries like `cmd-ts` that provide type-safe argument parsing, eliminating `any` types and improving developer experience.
- **Validation at parse time**: Move validation logic into the parser rather than command handlers. This provides better error messages with context.
- **Positional vs named arguments**: Support both positional arguments (`<path>`) and named options (`--flag`, `--option=value`) with proper typing.
- **Custom types**: Build custom parser types for domain-specific validation (file paths, URLs, enums) to centralize validation logic.

### Error Handling

- **Custom error classes**: Create domain-specific error classes extending `Error` with union types for error names, enabling type-safe error handling and better IntelliSense.
- **Error hierarchy**: Use a base `ErrorBase` class with generics to maintain DRY principles across multiple error types.
- **Structured error handling pattern**:
  - Low-level functions: throw meaningful errors with context
  - Expected cases: return appropriate values instead of throwing
  - Business logic violations: throw with clear, actionable messages
  - Command handlers: catch all errors in one place, present friendly feedback, use `process.exit(1)` for failures
- **Error messages**: Be specific and actionable—tell users exactly what went wrong and how to fix it.
- **Exit codes**: Use `process.exit(1)` so scripts and shells know something failed.

### Code Organization

- **Modularization**: Break down complex commands into smaller functions or modules for better maintainability.
- **TypeScript interfaces**: Define interfaces for command options and arguments to improve type safety and documentation.
- **Command structure**: Separate command definitions from business logic, enabling easier testing and code reuse.
- **Entry point**: Use `#!/usr/bin/env node` shebang and proper command parsing setup.

### Testing

- **Unit testing**: Write unit tests for command modules to ensure they work as expected. Type-safe parsers make testing easier by allowing direct function calls with typed arguments.
- **Testable architecture**: Design CLI code to be testable by separating parsing logic from command handlers.
- **Testing frameworks**: Use frameworks like Vitest, Jest, or Karma/Jasmine depending on project setup.

### User Experience

- **Autogenerated help**: Leverage framework features for automatic `--help` generation.
- **User feedback**: Provide clear and informative feedback, especially when handling errors or validating input.
- **Command aliases**: Consider adding command aliases for convenience (e.g., `list` as alias for `list-repos`).
- **Input validation**: Validate user input early in the parsing phase with helpful error messages.

## Detailed Analysis

The search reveals three primary approaches to TypeScript CLI development, each with different trade-offs:

**Traditional approach (Commander/yargs)**: These libraries are mature and widely used, but they sacrifice type safety. Arguments are typically typed as `any`, requiring manual type assertions and validation in command handlers. This approach works well for simple CLIs but can lead to runtime errors and reduced developer confidence.

**Type-driven approach (cmd-ts)**: This newer library prioritizes type safety by treating argument parsing as a type-level concern. Arguments are parsed into specific types at both compile-time and runtime, eliminating `any` types entirely. Validation logic is moved into the parser itself, making errors more contextual and easier to test. This approach is particularly valuable for complex CLIs where type safety reduces bugs.

**Framework approach (oclif)**: Provides a complete CLI framework with built-in features like testing, documentation generation, and plugin systems. Ideal for large-scale CLI applications that need more than just argument parsing.

Error handling emerges as a critical concern across all approaches. The recommended pattern involves creating custom error classes with union types for error names, enabling type-safe error handling with `instanceof` checks. Errors should be thrown at appropriate levels (low-level functions throw with context, business logic throws actionable errors), while command handlers catch and present user-friendly messages.

Testing is significantly easier with type-safe parsers, as command handlers can be tested directly without needing to construct command-line argument strings. This separation of concerns—parsing vs. execution—makes CLI code more maintainable and testable.

## Sources

- **[medium.com] Building a Powerful Command-Line Interface (CLI) Tool in TypeScript**: https://medium.com/@WC_/building-a-powerful-command-line-interface-cli-tool-in-typescript-a-step-by-step-guide-3eac3837e190
- **[gal.hagever.com] CLI Apps in TypeScript with `cmd-ts` (Part 1)**: https://gal.hagever.com/posts/type-safe-cli-apps-in-typescript-with-cmd-ts-part-1
- **[rahul1999.medium.com] How to Create a Testable CLI using TypeScript?**: https://rahul1999.medium.com/how-to-create-a-testable-cli-using-typescript-e374a4166100
- **[engineering.udacity.com] Handling errors like a pro in TypeScript**: https://engineering.udacity.com/handling-errors-like-a-pro-in-typescript-d7a314ad4991
- **[www.typescriptlang.org] Documentation - tsc CLI Options**: https://www.typescriptlang.org/docs/handbook/compiler-options.html
- **[www.joshcanhelp.com] Building a CLI from scratch with TypeScript and oclif**: https://www.joshcanhelp.com/oclif/
- **[www.testim.io] TypeScript Unit Testing 101: A Developer's Guide**: https://www.testim.io/blog/typescript-unit-testing-101/
- **[github.com] Schniz/cmd-ts: A type-driven command line argument parser**: https://github.com/Schniz/cmd-ts
- **[akos.ma] Starting a Typescript CLI Project from Scratch**: https://akos.ma/blog/starting-a-typescript-cli-project-from-scratch/
- **[stackoverflow.com] How to run TypeScript files from command line?**: https://stackoverflow.com/questions/33535879/how-to-run-typescript-files-from-command-line
- **[medium.com] Error Handling in CLI Tools: A Practical Pattern That's Worked for Me**: https://medium.com/@czhoudev/error-handling-in-cli-tools-a-practical-pattern-thats-worked-for-me-6c658a9141a9
- **[stackoverflow.com] How to retrieve command-line args which was passed during building**: https://stackoverflow.com/questions/59178648/how-to-retrieve-command-line-args-which-was-passed-during-building-custom-build
- **[learn.microsoft.com] Unit testing JavaScript and TypeScript in Visual Studio**: https://learn.microsoft.com/en-us/visualstudio/javascript/unit-testing-javascript-with-visual-studio?view=vs-2022
- **[stackoverflow.com] How to check TypeScript code for syntax errors from a command line?**: https://stackoverflow.com/questions/41542907/how-to-check-typescript-code-for-syntax-errors-from-a-command-line

