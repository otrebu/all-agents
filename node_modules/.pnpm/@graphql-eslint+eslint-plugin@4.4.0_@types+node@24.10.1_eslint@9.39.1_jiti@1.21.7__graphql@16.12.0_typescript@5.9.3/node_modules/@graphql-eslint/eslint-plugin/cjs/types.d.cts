import { Rule, AST, Linter } from 'eslint';
import * as ESTree from 'estree';
import { GraphQLSchema, ASTKindToNode } from 'graphql';
import { IGraphQLConfig } from 'graphql-config';
import { JSONSchema } from 'json-schema-to-ts';
import { GraphQLESTreeNode } from './estree-converter/types.cjs';
import { SiblingOperations } from './siblings.cjs';
import '@graphql-tools/utils';

type Schema = GraphQLSchema | null;
type Pointer = string | string[];

type ParserConfigGraphQLConfig = {
    graphQLConfig?: IGraphQLConfig;
    filePath: string;
};
type ParserConfigProgrammatic = {
    schemaSdl: string;
    filePath: string;
};
type ParserOptions = ParserConfigGraphQLConfig | ParserConfigProgrammatic;
type ParserServices = {
    schema: Schema;
    siblingOperations: SiblingOperations;
};
type GraphQLESLintParseResult = Linter.ESLintParseResult & {
    services: ParserServices;
};
type Location = AST.SourceLocation | ESTree.Position;
type ReportDescriptorLocation = {
    loc: Location;
} | {
    node: {
        loc: Location;
    };
};
type ReportDescriptor = ReportDescriptorLocation & Rule.ReportDescriptorMessage & Rule.ReportDescriptorOptions;
type GraphQLESLintRuleContext<Options = any[]> = Omit<Rule.RuleContext, 'options' | 'parserServices' | 'report'> & {
    options: Options;
    parserServices: ParserServices;
    report(descriptor: ReportDescriptor): void;
};
type CategoryType = 'Operations' | 'Schema';
type RuleMetaDataDocs = Required<Rule.RuleMetaData>['docs'];
type RuleDocsInfo<T> = Omit<RuleMetaDataDocs, 'category' | 'suggestion'> & {
    category: CategoryType | CategoryType[];
    requiresSchema?: true;
    requiresSiblings?: true;
    examples?: {
        title: string;
        code: string;
        usage?: T;
    }[];
    configOptions?: T | {
        schema?: T;
        operations?: T;
    };
    graphQLJSRuleName?: string;
    isDisabledForAllConfig?: true;
    whenNotToUseIt?: string;
};
type GraphQLESLintRuleListener<WithTypeInfo extends boolean = false> = Record<string, any> & {
    [K in keyof ASTKindToNode]?: (node: GraphQLESTreeNode<ASTKindToNode[K], WithTypeInfo>) => void;
};
type GraphQLESLintRule<Options = [], WithTypeInfo extends boolean = false> = {
    meta: Omit<Rule.RuleMetaData, 'docs' | 'schema'> & {
        docs?: RuleDocsInfo<Options>;
        schema: Readonly<JSONSchema> | [];
    };
    create(context: GraphQLESLintRuleContext<Options>): GraphQLESLintRuleListener<WithTypeInfo>;
};
type ValueOf<T> = T[keyof T];
type Id<T> = {
    [P in keyof T]: T[P];
} & {};
type OmitDistributive<T, K extends PropertyKey> = T extends object ? Id<OmitRecursively<T, K>> : T;
type OmitRecursively<T extends object, K extends PropertyKey> = Omit<{
    [P in keyof T]: OmitDistributive<T[P], K>;
}, K>;
type ConfigName = 'operations-all' | 'operations-recommended' | 'schema-all' | 'schema-recommended' | 'schema-relay';

export { type CategoryType, type ConfigName, type GraphQLESLintParseResult, type GraphQLESLintRule, type GraphQLESLintRuleContext, type GraphQLESLintRuleListener, GraphQLESTreeNode, type OmitRecursively, type ParserConfigGraphQLConfig, type ParserConfigProgrammatic, type ParserOptions, type ParserServices, type Pointer, type ReportDescriptor, type RuleDocsInfo, type Schema, type ValueOf };
