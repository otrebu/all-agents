"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } function _optionalChain(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }var _debug = require('debug'); var _debug2 = _interopRequireDefault(_debug);
var _graphql = require('graphql');
var _utils = require('@graphql-tools/utils');
var _documentsjs = require('./documents.js');
var _indexjs = require('./estree-converter/index.js');
var _graphqlconfigjs = require('./graphql-config.js');
var _metajs = require('./meta.js');
var _schemajs = require('./schema.js');
var _siblingsjs = require('./siblings.js');
var _utilsjs = require('./utils.js');
const debug = _debug2.default.call(void 0, "graphql-eslint:parser");
debug("cwd %o", _utilsjs.CWD);
const LEGACY_PARSER_OPTIONS_KEYS = [
  "schema",
  "documents",
  "extensions",
  "include",
  "exclude",
  "projects",
  "schemaOptions",
  "graphQLParserOptions",
  "skipGraphQLConfig",
  "operations"
];
function parseForESLint(code, options) {
  for (const key of LEGACY_PARSER_OPTIONS_KEYS) {
    if (key in options) {
      throw new Error(
        `\`parserOptions.${key}\` was removed in graphql-eslint@4. Use physical graphql-config for setting schema and documents or \`parserOptions.graphQLConfig\` for programmatic usage.`
      );
    }
  }
  try {
    const { filePath } = options;
    const { document } = _utils.parseGraphQLSDL.call(void 0, filePath, code, { noLocation: false });
    let project;
    let schema, documents = [];
    if ("schemaSdl" in options) {
      schema = _graphql.buildSchema.call(void 0, options.schemaSdl);
    } else {
      if (true) {
        const gqlConfig = _graphqlconfigjs.loadGraphQLConfig.call(void 0, options);
        project = gqlConfig.getProjectForFile(_graphqlconfigjs.getFirstExistingPath.call(void 0, filePath));
        documents = _documentsjs.getDocuments.call(void 0, project);
      } else {
        documents = [
          _utils.parseGraphQLSDL.call(void 0, 
            "operation.graphql",
            options.graphQLConfig.documents,
            { noLocation: true }
          )
        ];
      }
      try {
        if (true) {
          schema = _schemajs.getSchema.call(void 0, project);
        } else {
          schema = _graphql.buildSchema.call(void 0, options.graphQLConfig.schema);
        }
      } catch (error) {
        if (error instanceof Error) {
          error.message = `Error while loading schema: ${error.message}`;
        }
        throw error;
      }
    }
    const rootTree = _indexjs.convertToESTree.call(void 0, document, schema);
    return {
      services: {
        schema,
        siblingOperations: _siblingsjs.getSiblings.call(void 0, documents)
      },
      ast: {
        comments: _indexjs.extractComments.call(void 0, document.loc),
        tokens: _indexjs.extractTokens.call(void 0, filePath, code),
        loc: rootTree.loc,
        range: rootTree.range,
        type: "Program",
        sourceType: "script",
        body: [rootTree]
      }
    };
  } catch (error) {
    if (error instanceof Error) {
      error.message = `[graphql-eslint] ${error.message}`;
    }
    if (error instanceof _graphql.GraphQLError) {
      const location = _optionalChain([error, 'access', _ => _.locations, 'optionalAccess', _2 => _2[0]]);
      const eslintError = {
        index: _optionalChain([error, 'access', _3 => _3.positions, 'optionalAccess', _4 => _4[0]]),
        ...location && {
          lineNumber: location.line,
          column: location.column - 1
        },
        message: error.message
      };
      throw eslintError;
    }
    throw error;
  }
}
const parser = {
  parseForESLint,
  meta: {
    name: "@graphql-eslint/parser",
    version: _metajs.version
  }
};



exports.parseForESLint = parseForESLint; exports.parser = parser;
