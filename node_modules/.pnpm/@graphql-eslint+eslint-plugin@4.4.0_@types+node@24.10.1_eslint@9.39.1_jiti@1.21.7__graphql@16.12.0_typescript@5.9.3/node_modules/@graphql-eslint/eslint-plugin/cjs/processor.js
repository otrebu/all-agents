"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _optionalChain(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }var _nodepath = require('node:path');


var _graphqltagpluck = require('@graphql-tools/graphql-tag-pluck');
var _utils = require('@graphql-tools/utils');
var _graphqlconfigjs = require('./graphql-config.js');
var _metajs = require('./meta.js');
var _utilsjs = require('./utils.js');
const blocksMap = /* @__PURE__ */ new Map();
let onDiskConfig;
let onDiskConfigLoaded = false;
const RELEVANT_KEYWORDS = ["gql", "graphql", "GraphQL"];
const processor = {
  meta: {
    name: "@graphql-eslint/processor",
    version: _metajs.version
  },
  supportsAutofix: true,
  preprocess(code, filePath) {
    if (process.env.ESLINT_USE_FLAT_CONFIG !== "false" && filePath.endsWith(".vue")) {
      throw new Error(
        "Processing of `.vue` files is no longer supported, follow the new official vue example for ESLint's flat config https://github.com/dimaMachina/graphql-eslint/tree/master/examples/vue-code-file"
      );
    }
    if (!onDiskConfigLoaded) {
      onDiskConfig = _graphqlconfigjs.loadOnDiskGraphQLConfig.call(void 0, filePath);
      onDiskConfigLoaded = true;
    }
    let keywords = RELEVANT_KEYWORDS;
    const pluckConfig = _optionalChain([onDiskConfig, 'optionalAccess', _ => _.getProjectForFile, 'call', _2 => _2(filePath), 'access', _3 => _3.extensions, 'access', _4 => _4.pluckConfig]);
    if (pluckConfig) {
      const {
        modules = [],
        globalGqlIdentifierName = ["gql", "graphql"],
        gqlMagicComment = "GraphQL"
      } = pluckConfig;
      const mods = modules.map(({ identifier }) => identifier).filter((v) => !!v);
      const result = [...mods, ..._utils.asArray.call(void 0, globalGqlIdentifierName), gqlMagicComment];
      keywords = [...new Set(result)];
    }
    if (keywords.every((keyword) => !code.includes(keyword))) {
      return [code];
    }
    try {
      const sources = _graphqltagpluck.gqlPluckFromCodeStringSync.call(void 0, filePath, code, {
        skipIndent: true,
        ...pluckConfig
      });
      const blocks = sources.map((item) => ({
        filename: "document.graphql",
        text: item.body,
        lineOffset: item.locationOffset.line - 1,
        // @ts-expect-error -- `index` field exist but show ts error
        offset: item.locationOffset.index + 1
      }));
      blocksMap.set(filePath, blocks);
      return [
        ...blocks,
        code
        /* source code must be provided and be last */
      ];
    } catch (error) {
      if (error instanceof Error) {
        error.message = `[graphql-eslint] Error while preprocessing "${_nodepath.relative.call(void 0, 
          _utilsjs.CWD,
          filePath
        )}" file

${error.message}`;
      }
      console.error(error);
      return [code];
    }
  },
  postprocess(messages, filePath) {
    const blocks = blocksMap.get(filePath) || [];
    for (let i = 0; i < blocks.length; i += 1) {
      const { lineOffset, offset } = blocks[i];
      for (const message of messages[i] || []) {
        const isVueOrSvelte = /\.(vue|svelte)$/.test(filePath);
        if (isVueOrSvelte) {
          delete message.endLine;
          delete message.endColumn;
          delete message.fix;
          delete message.suggestions;
          Object.assign(message, _utilsjs.REPORT_ON_FIRST_CHARACTER);
          continue;
        }
        message.line += lineOffset;
        if (typeof message.endLine === "number") {
          message.endLine += lineOffset;
        }
        if (message.fix) {
          message.fix.range[0] += offset;
          message.fix.range[1] += offset;
        }
        for (const suggestion of message.suggestions || []) {
          const [start, end] = suggestion.fix.range;
          suggestion.fix.range = [start + offset, end + offset];
        }
      }
    }
    const result = messages.flat();
    return result.sort((a, b) => a.line - b.line || a.column - b.column);
  }
};


exports.processor = processor;
