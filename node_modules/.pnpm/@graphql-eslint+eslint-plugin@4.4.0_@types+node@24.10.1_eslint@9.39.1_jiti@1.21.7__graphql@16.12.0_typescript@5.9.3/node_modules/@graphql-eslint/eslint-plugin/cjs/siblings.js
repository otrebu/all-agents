"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _optionalChain(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }


var _graphql = require('graphql');
var _utilsjs = require('./utils.js');
const siblingOperationsCache = /* @__PURE__ */ new Map();
function getSiblings(documents) {
  if (documents.length === 0) {
    let printed = false;
    const noopWarn = () => {
      if (!printed) {
        _utilsjs.logger.warn(
          "getSiblingOperations was called without any operations. Make sure to set graphql-config `documents` field to make this feature available! See https://the-guild.dev/graphql/config/docs/user/documents for more info"
        );
        printed = true;
      }
      return [];
    };
    return {
      available: false,
      getFragment: noopWarn,
      getFragments: noopWarn,
      getFragmentByType: noopWarn,
      getFragmentsInUse: noopWarn,
      getOperation: noopWarn,
      getOperations: noopWarn,
      getOperationByType: noopWarn
    };
  }
  const value = siblingOperationsCache.get(documents);
  if (value) {
    return value;
  }
  let fragmentsCache = null;
  const getFragments = () => {
    if (fragmentsCache === null) {
      const result = [];
      for (const source of documents) {
        for (const definition of _optionalChain([source, 'access', _ => _.document, 'optionalAccess', _2 => _2.definitions]) || []) {
          if (definition.kind === _graphql.Kind.FRAGMENT_DEFINITION) {
            result.push({
              filePath: source.location,
              document: definition
            });
          }
        }
      }
      fragmentsCache = result;
    }
    return fragmentsCache;
  };
  let cachedOperations = null;
  const getOperations = () => {
    if (cachedOperations === null) {
      const result = [];
      for (const source of documents) {
        for (const definition of _optionalChain([source, 'access', _3 => _3.document, 'optionalAccess', _4 => _4.definitions]) || []) {
          if (definition.kind === _graphql.Kind.OPERATION_DEFINITION) {
            result.push({
              filePath: source.location,
              document: definition
            });
          }
        }
      }
      cachedOperations = result;
    }
    return cachedOperations;
  };
  const getFragment = (name) => getFragments().filter((f) => f.document.name.value === name);
  const collectFragments = (selectable, recursive, collected = /* @__PURE__ */ new Map()) => {
    _graphql.visit.call(void 0, selectable, {
      FragmentSpread(spread) {
        const fragmentName = spread.name.value;
        const [fragment] = getFragment(fragmentName);
        if (!fragment) {
          _utilsjs.logger.warn(
            `Unable to locate fragment named "${fragmentName}", please make sure it's loaded using "parserOptions.operations"`
          );
          return;
        }
        if (!collected.has(fragmentName)) {
          collected.set(fragmentName, fragment.document);
          if (recursive) {
            collectFragments(fragment.document, recursive, collected);
          }
        }
      }
    });
    return collected;
  };
  const siblingOperations = {
    available: true,
    getFragment,
    getFragments,
    getFragmentByType: (typeName) => getFragments().filter((f) => f.document.typeCondition.name.value === typeName),
    getFragmentsInUse: (selectable, recursive = true) => Array.from(collectFragments(selectable, recursive).values()),
    getOperation: (name) => getOperations().filter((o) => _optionalChain([o, 'access', _5 => _5.document, 'access', _6 => _6.name, 'optionalAccess', _7 => _7.value]) === name),
    getOperations,
    getOperationByType: (type) => getOperations().filter((o) => o.document.operation === type)
  };
  siblingOperationsCache.set(documents, siblingOperations);
  return siblingOperations;
}


exports.getSiblings = getSiblings;
