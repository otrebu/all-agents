"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _optionalChain(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }var _graphql = require('graphql');





var _utilsjs = require('../../utils.js');
const RULE_ID = "strict-id-in-types";
const schema = {
  type: "array",
  maxItems: 1,
  items: {
    type: "object",
    additionalProperties: false,
    properties: {
      acceptedIdNames: {
        ..._utilsjs.ARRAY_DEFAULT_OPTIONS,
        default: ["id"]
      },
      acceptedIdTypes: {
        ..._utilsjs.ARRAY_DEFAULT_OPTIONS,
        default: ["ID"]
      },
      exceptions: {
        type: "object",
        additionalProperties: false,
        properties: {
          types: {
            ..._utilsjs.ARRAY_DEFAULT_OPTIONS,
            description: "This is used to exclude types with names that match one of the specified values."
          },
          suffixes: {
            ..._utilsjs.ARRAY_DEFAULT_OPTIONS,
            description: "This is used to exclude types with names with suffixes that match one of the specified values."
          }
        }
      }
    }
  }
};
const rule = {
  meta: {
    type: "suggestion",
    docs: {
      description: "Requires output types to have one unique identifier unless they do not have a logical one. Exceptions can be used to ignore output types that do not have unique identifiers.",
      category: "Schema",
      recommended: true,
      url: `https://the-guild.dev/graphql/eslint/rules/${RULE_ID}`,
      requiresSchema: true,
      examples: [
        {
          title: "Incorrect",
          usage: [
            {
              acceptedIdNames: ["id", "_id"],
              acceptedIdTypes: ["ID"],
              exceptions: { suffixes: ["Payload"] }
            }
          ],
          code: (
            /* GraphQL */
            `
            # Incorrect field name
            type InvalidFieldName {
              key: ID!
            }

            # Incorrect field type
            type InvalidFieldType {
              id: String!
            }

            # Incorrect exception suffix
            type InvalidSuffixResult {
              data: String!
            }

            # Too many unique identifiers. Must only contain one.
            type InvalidFieldName {
              id: ID!
              _id: ID!
            }
          `
          )
        },
        {
          title: "Correct",
          usage: [
            {
              acceptedIdNames: ["id", "_id"],
              acceptedIdTypes: ["ID"],
              exceptions: { types: ["Error"], suffixes: ["Payload"] }
            }
          ],
          code: (
            /* GraphQL */
            `
            type User {
              id: ID!
            }

            type Post {
              _id: ID!
            }

            type CreateUserPayload {
              data: String!
            }

            type Error {
              message: String!
            }
          `
          )
        }
      ]
    },
    schema
  },
  create(context) {
    const options = {
      acceptedIdNames: ["id"],
      acceptedIdTypes: ["ID"],
      exceptions: {},
      ...context.options[0]
    };
    const schema2 = _utilsjs.requireGraphQLSchema.call(void 0, RULE_ID, context);
    const rootTypeNames = [
      schema2.getQueryType(),
      schema2.getMutationType(),
      schema2.getSubscriptionType()
    ].filter((v) => !!v).map((type) => type.name);
    const selector = `ObjectTypeDefinition[name.value!=/^(${rootTypeNames.join("|")})$/]`;
    return {
      [selector](node) {
        const typeName = node.name.value;
        const shouldIgnoreNode = _optionalChain([options, 'access', _ => _.exceptions, 'access', _2 => _2.types, 'optionalAccess', _3 => _3.includes, 'call', _4 => _4(typeName)]) || _optionalChain([options, 'access', _5 => _5.exceptions, 'access', _6 => _6.suffixes, 'optionalAccess', _7 => _7.some, 'call', _8 => _8((suffix) => typeName.endsWith(suffix))]);
        if (shouldIgnoreNode) {
          return;
        }
        const validIds = _optionalChain([node, 'access', _9 => _9.fields, 'optionalAccess', _10 => _10.filter, 'call', _11 => _11((field) => {
          const fieldNode = field.rawNode();
          const isValidIdName = options.acceptedIdNames.includes(fieldNode.name.value);
          let isValidIdType = false;
          if (fieldNode.type.kind === _graphql.Kind.NON_NULL_TYPE && fieldNode.type.type.kind === _graphql.Kind.NAMED_TYPE) {
            isValidIdType = options.acceptedIdTypes.includes(fieldNode.type.type.name.value);
          }
          return isValidIdName && isValidIdType;
        })]);
        if (_optionalChain([validIds, 'optionalAccess', _12 => _12.length]) !== 1) {
          const pluralNamesSuffix = options.acceptedIdNames.length > 1 ? "s" : "";
          const pluralTypesSuffix = options.acceptedIdTypes.length > 1 ? "s" : "";
          context.report({
            node: node.name,
            message: `${_utilsjs.displayNodeName.call(void 0, node)} must have exactly one non-nullable unique identifier.
Accepted name${pluralNamesSuffix}: ${_utilsjs.englishJoinWords.call(void 0, options.acceptedIdNames)}.
Accepted type${pluralTypesSuffix}: ${_utilsjs.englishJoinWords.call(void 0, options.acceptedIdTypes)}.`
          });
        }
      }
    };
  }
};


exports.rule = rule;
