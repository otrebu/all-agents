"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _optionalChain(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }var _graphql = require('graphql');
var _utilsjs = require('../../utils.js');
const RULE_ID = "relay-arguments";
const MISSING_ARGUMENTS = "MISSING_ARGUMENTS";
const schema = {
  type: "array",
  maxItems: 1,
  items: {
    type: "object",
    additionalProperties: false,
    minProperties: 1,
    properties: {
      includeBoth: {
        type: "boolean",
        default: true,
        description: "Enforce including both forward and backward pagination arguments"
      }
    }
  }
};
const rule = {
  meta: {
    type: "problem",
    docs: {
      category: "Schema",
      description: [
        "Set of rules to follow Relay specification for Arguments.",
        "",
        "- A field that returns a Connection type must include forward pagination arguments (`first` and `after`), backward pagination arguments (`last` and `before`), or both",
        "",
        "Forward pagination arguments",
        "",
        "- `first` takes a non-negative integer",
        "- `after` takes the Cursor type",
        "",
        "Backward pagination arguments",
        "",
        "- `last` takes a non-negative integer",
        "- `before` takes the Cursor type"
      ].join("\n"),
      url: `https://the-guild.dev/graphql/eslint/rules/${RULE_ID}`,
      examples: [
        {
          title: "Incorrect",
          code: (
            /* GraphQL */
            `
            type User {
              posts: PostConnection
            }
          `
          )
        },
        {
          title: "Correct",
          code: (
            /* GraphQL */
            `
            type User {
              posts(after: String, first: Int, before: String, last: Int): PostConnection
            }
          `
          )
        }
      ],
      isDisabledForAllConfig: true
    },
    messages: {
      [MISSING_ARGUMENTS]: "A field that returns a Connection type must include forward pagination arguments (`first` and `after`), backward pagination arguments (`last` and `before`), or both."
    },
    schema
  },
  create(context) {
    const schema2 = _utilsjs.requireGraphQLSchema.call(void 0, RULE_ID, context);
    const { includeBoth = true } = context.options[0] || {};
    return {
      "FieldDefinition > .gqlType Name[value=/Connection$/]"(node) {
        let fieldNode = node.parent;
        while (fieldNode.kind !== _graphql.Kind.FIELD_DEFINITION) {
          fieldNode = fieldNode.parent;
        }
        const args = Object.fromEntries(
          _optionalChain([fieldNode, 'access', _ => _.arguments, 'optionalAccess', _2 => _2.map, 'call', _3 => _3((argument) => [argument.name.value, argument])]) || []
        );
        const hasForwardPagination = !!(args.first && args.after);
        const hasBackwardPagination = !!(args.last && args.before);
        if (!hasForwardPagination && !hasBackwardPagination) {
          context.report({
            node: fieldNode.name,
            messageId: MISSING_ARGUMENTS
          });
          return;
        }
        function checkField(typeName, argumentName) {
          const argument = args[argumentName];
          const hasArgument = !!argument;
          let type = argument;
          if (hasArgument && type.gqlType.kind === _graphql.Kind.NON_NULL_TYPE) {
            type = type.gqlType;
          }
          const isAllowedNonNullType = hasArgument && type.gqlType.kind === _graphql.Kind.NAMED_TYPE && (type.gqlType.name.value === typeName || typeName === "String" && _graphql.isScalarType.call(void 0, schema2.getType(type.gqlType.name.value)));
          if (!isAllowedNonNullType) {
            const returnType = typeName === "String" ? "String or Scalar" : typeName;
            context.report({
              node: (argument || fieldNode).name,
              message: hasArgument ? `Argument \`${argumentName}\` must return ${returnType}.` : `Field \`${fieldNode.name.value}\` must contain an argument \`${argumentName}\`, that return ${returnType}.`
            });
          }
        }
        if (includeBoth || args.first || args.after) {
          checkField("Int", "first");
          checkField("String", "after");
        }
        if (includeBoth || args.last || args.before) {
          checkField("Int", "last");
          checkField("String", "before");
        }
      }
    };
  }
};


exports.rule = rule;
