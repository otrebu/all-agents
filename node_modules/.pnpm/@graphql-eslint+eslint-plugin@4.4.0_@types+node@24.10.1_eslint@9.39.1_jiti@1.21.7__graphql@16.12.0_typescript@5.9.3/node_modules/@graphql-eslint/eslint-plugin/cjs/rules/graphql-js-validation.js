"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _optionalChain(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }



var _graphql = require('graphql');































var _indexjs = require('graphql/validation/index.js');
var _validatejs = require('graphql/validation/validate.js');





var _utilsjs = require('../utils.js');
function validateDocument({
  context,
  schema = null,
  documentNode,
  rule,
  hasDidYouMeanSuggestions
}) {
  if (documentNode.definitions.length === 0) {
    return;
  }
  try {
    const validationErrors = schema ? _graphql.validate.call(void 0, schema, documentNode, [rule]) : _validatejs.validateSDL.call(void 0, documentNode, null, [rule]);
    for (const error of validationErrors) {
      const { line, column } = error.locations[0];
      const sourceCode = context.getSourceCode();
      const { tokens } = sourceCode.ast;
      const token = tokens.find(
        (token2) => token2.loc.start.line === line && token2.loc.start.column === column - 1
      );
      let loc = {
        line,
        column: column - 1
      };
      if (token) {
        loc = // if cursor on `@` symbol than use next node
        token.type === "@" ? sourceCode.getNodeByRangeIndex(token.range[1] + 1).loc : token.loc;
      }
      const didYouMeanContent = _optionalChain([error, 'access', _ => _.message, 'access', _2 => _2.match, 'call', _3 => _3(/Did you mean (?<content>.*)\?$/), 'optionalAccess', _4 => _4.groups, 'access', _5 => _5.content]);
      const matches = didYouMeanContent ? [...didYouMeanContent.matchAll(/"(?<name>[^"]*)"/g)] : [];
      context.report({
        loc,
        message: error.message,
        suggest: hasDidYouMeanSuggestions ? matches.map((match) => {
          const { name } = match.groups;
          return {
            desc: `Rename to \`${name}\``,
            fix: (fixer) => fixer.replaceText(token, name)
          };
        }) : []
      });
    }
  } catch (error) {
    context.report({
      loc: _utilsjs.REPORT_ON_FIRST_CHARACTER,
      message: error.message
    });
  }
}
const getFragmentDefsAndFragmentSpreads = (node) => {
  const fragmentDefs = /* @__PURE__ */ new Set();
  const fragmentSpreads = /* @__PURE__ */ new Set();
  const visitor = {
    FragmentDefinition(node2) {
      fragmentDefs.add(node2.name.value);
    },
    FragmentSpread(node2) {
      fragmentSpreads.add(node2.name.value);
    }
  };
  _graphql.visit.call(void 0, node, visitor);
  return { fragmentDefs, fragmentSpreads };
};
const getMissingFragments = (node) => {
  const { fragmentDefs, fragmentSpreads } = getFragmentDefsAndFragmentSpreads(node);
  return [...fragmentSpreads].filter((name) => !fragmentDefs.has(name));
};
const handleMissingFragments = ({ ruleId, context, node }) => {
  const missingFragments = getMissingFragments(node);
  if (missingFragments.length > 0) {
    const siblings = _utilsjs.requireGraphQLOperations.call(void 0, ruleId, context);
    const fragmentsToAdd = [];
    for (const fragmentName of missingFragments) {
      const [foundFragment] = siblings.getFragment(fragmentName).map((source) => source.document);
      if (foundFragment) {
        fragmentsToAdd.push(foundFragment);
      }
    }
    if (fragmentsToAdd.length > 0) {
      return handleMissingFragments({
        ruleId,
        context,
        node: {
          kind: _graphql.Kind.DOCUMENT,
          definitions: [...node.definitions, ...fragmentsToAdd]
        }
      });
    }
  }
  return node;
};
const validationToRule = ({
  ruleId,
  rule,
  getDocumentNode,
  schema = [],
  hasDidYouMeanSuggestions
}, docs) => {
  return {
    [ruleId]: {
      meta: {
        docs: {
          recommended: true,
          ...docs,
          graphQLJSRuleName: rule.name,
          url: `https://the-guild.dev/graphql/eslint/rules/${ruleId}`,
          description: `${docs.description}
> This rule is a wrapper around a \`graphql-js\` validation function.`
        },
        schema,
        hasSuggestions: hasDidYouMeanSuggestions
      },
      create(context) {
        return {
          Document(node) {
            const schema2 = docs.requiresSchema ? _utilsjs.requireGraphQLSchema.call(void 0, ruleId, context) : null;
            const documentNode = getDocumentNode ? getDocumentNode({ ruleId, context, node: node.rawNode() }) : node.rawNode();
            validateDocument({
              context,
              schema: schema2,
              documentNode,
              rule,
              hasDidYouMeanSuggestions
            });
          }
        };
      }
    }
  };
};
const GRAPHQL_JS_VALIDATIONS = Object.assign(
  {},
  validationToRule(
    {
      ruleId: "executable-definitions",
      rule: _indexjs.ExecutableDefinitionsRule
    },
    {
      category: "Operations",
      description: "A GraphQL document is only valid for execution if all definitions are either operation or fragment definitions.",
      requiresSchema: true
    }
  ),
  validationToRule(
    {
      ruleId: "fields-on-correct-type",
      rule: _indexjs.FieldsOnCorrectTypeRule,
      hasDidYouMeanSuggestions: true
    },
    {
      category: "Operations",
      description: "A GraphQL document is only valid if all fields selected are defined by the parent type, or are an allowed meta field such as `__typename`.",
      requiresSchema: true
    }
  ),
  validationToRule(
    {
      ruleId: "fragments-on-composite-type",
      rule: _indexjs.FragmentsOnCompositeTypesRule
    },
    {
      category: "Operations",
      description: "Fragments use a type condition to determine if they apply, since fragments can only be spread into a composite type (object, interface, or union), the type condition must also be a composite type.",
      requiresSchema: true
    }
  ),
  validationToRule(
    {
      ruleId: "known-argument-names",
      rule: _indexjs.KnownArgumentNamesRule,
      hasDidYouMeanSuggestions: true
    },
    {
      category: ["Schema", "Operations"],
      description: "A GraphQL field is only valid if all supplied arguments are defined by that field.",
      requiresSchema: true
    }
  ),
  validationToRule(
    {
      ruleId: "known-directives",
      rule: _indexjs.KnownDirectivesRule,
      getDocumentNode({ context, node: documentNode }) {
        const { ignoreClientDirectives = [] } = context.options[0] || {};
        if (ignoreClientDirectives.length === 0) {
          return documentNode;
        }
        const filterDirectives = (node) => ({
          ...node,
          directives: _optionalChain([node, 'access', _6 => _6.directives, 'optionalAccess', _7 => _7.filter, 'call', _8 => _8(
            (directive) => !ignoreClientDirectives.includes(directive.name.value)
          )])
        });
        return _graphql.visit.call(void 0, documentNode, {
          Field: filterDirectives,
          OperationDefinition: filterDirectives
        });
      },
      schema: {
        type: "array",
        maxItems: 1,
        items: {
          type: "object",
          additionalProperties: false,
          required: ["ignoreClientDirectives"],
          properties: {
            ignoreClientDirectives: _utilsjs.ARRAY_DEFAULT_OPTIONS
          }
        }
      }
    },
    {
      category: ["Schema", "Operations"],
      description: "A GraphQL document is only valid if all `@directive`s are known by the schema and legally positioned.",
      requiresSchema: true,
      examples: [
        {
          title: "Valid",
          usage: [{ ignoreClientDirectives: ["client"] }],
          code: (
            /* GraphQL */
            `
            {
              product {
                someClientField @client
              }
            }
          `
          )
        }
      ]
    }
  ),
  validationToRule(
    {
      ruleId: "known-fragment-names",
      rule: _indexjs.KnownFragmentNamesRule,
      getDocumentNode: handleMissingFragments
    },
    {
      category: "Operations",
      description: "A GraphQL document is only valid if all `...Fragment` fragment spreads refer to fragments defined in the same document.",
      requiresSchema: true,
      requiresSiblings: true,
      examples: [
        {
          title: "Incorrect",
          code: (
            /* GraphQL */
            `
            query {
              user {
                id
                ...UserFields # fragment not defined in the document
              }
            }
          `
          )
        },
        {
          title: "Correct",
          code: (
            /* GraphQL */
            `
            fragment UserFields on User {
              firstName
              lastName
            }

            query {
              user {
                id
                ...UserFields
              }
            }
          `
          )
        },
        {
          title: "Correct (`UserFields` fragment located in a separate file)",
          code: (
            /* GraphQL */
            `
            # user.gql
            query {
              user {
                id
                ...UserFields
              }
            }

            # user-fields.gql
            fragment UserFields on User {
              id
            }
          `
          )
        }
      ]
    }
  ),
  validationToRule(
    {
      ruleId: "known-type-names",
      rule: _indexjs.KnownTypeNamesRule,
      hasDidYouMeanSuggestions: true
    },
    {
      category: ["Schema", "Operations"],
      description: "A GraphQL document is only valid if referenced types (specifically variable definitions and fragment conditions) are defined by the type schema.",
      requiresSchema: true
    }
  ),
  validationToRule(
    {
      ruleId: "lone-anonymous-operation",
      rule: _indexjs.LoneAnonymousOperationRule
    },
    {
      category: "Operations",
      description: "A GraphQL document that contains an anonymous operation (the `query` short-hand) is only valid if it contains only that one operation definition.",
      requiresSchema: true
    }
  ),
  validationToRule(
    {
      ruleId: "lone-schema-definition",
      rule: _indexjs.LoneSchemaDefinitionRule
    },
    {
      category: "Schema",
      description: "A GraphQL document is only valid if it contains only one schema definition."
    }
  ),
  validationToRule(
    {
      ruleId: "no-fragment-cycles",
      rule: _indexjs.NoFragmentCyclesRule
    },
    {
      category: "Operations",
      description: "A GraphQL fragment is only valid when it does not have cycles in fragments usage.",
      requiresSchema: true
    }
  ),
  validationToRule(
    {
      ruleId: "no-undefined-variables",
      rule: _indexjs.NoUndefinedVariablesRule,
      getDocumentNode: handleMissingFragments
    },
    {
      category: "Operations",
      description: "A GraphQL operation is only valid if all variables encountered, both directly and via fragment spreads, are defined by that operation.",
      requiresSchema: true,
      requiresSiblings: true
    }
  ),
  validationToRule(
    {
      ruleId: "no-unused-fragments",
      rule: _indexjs.NoUnusedFragmentsRule,
      getDocumentNode: ({ ruleId, context, node }) => {
        const siblings = _utilsjs.requireGraphQLOperations.call(void 0, ruleId, context);
        const FilePathToDocumentsMap = [
          ...siblings.getOperations(),
          ...siblings.getFragments()
        ].reduce((map, { filePath, document }) => {
          map[filePath] ??= [];
          map[filePath].push(document);
          return map;
        }, /* @__PURE__ */ Object.create(null));
        const getParentNode = (currentFilePath, node2) => {
          const { fragmentDefs } = getFragmentDefsAndFragmentSpreads(node2);
          if (fragmentDefs.size === 0) {
            return node2;
          }
          delete FilePathToDocumentsMap[currentFilePath];
          for (const [filePath, documents] of Object.entries(FilePathToDocumentsMap)) {
            const missingFragments = getMissingFragments({
              kind: _graphql.Kind.DOCUMENT,
              definitions: documents
            });
            const isCurrentFileImportFragment = missingFragments.some(
              (fragment) => fragmentDefs.has(fragment)
            );
            if (isCurrentFileImportFragment) {
              return getParentNode(filePath, {
                kind: _graphql.Kind.DOCUMENT,
                definitions: [...node2.definitions, ...documents]
              });
            }
          }
          return node2;
        };
        return getParentNode(context.filename, node);
      }
    },
    {
      category: "Operations",
      description: "A GraphQL document is only valid if all fragment definitions are spread within operations, or spread within other fragments spread within operations.",
      requiresSchema: true,
      requiresSiblings: true
    }
  ),
  validationToRule(
    {
      ruleId: "no-unused-variables",
      rule: _indexjs.NoUnusedVariablesRule,
      getDocumentNode: handleMissingFragments
    },
    {
      category: "Operations",
      description: "A GraphQL operation is only valid if all variables defined by an operation are used, either directly or within a spread fragment.",
      requiresSchema: true,
      requiresSiblings: true
    }
  ),
  validationToRule(
    {
      ruleId: "overlapping-fields-can-be-merged",
      rule: _indexjs.OverlappingFieldsCanBeMergedRule
    },
    {
      category: "Operations",
      description: "A selection set is only valid if all fields (including spreading any fragments) either correspond to distinct response names or can be merged without ambiguity.",
      requiresSchema: true
    }
  ),
  validationToRule(
    {
      ruleId: "possible-fragment-spread",
      rule: _indexjs.PossibleFragmentSpreadsRule
    },
    {
      category: "Operations",
      description: "A fragment spread is only valid if the type condition could ever possibly be true: if there is a non-empty intersection of the possible parent types, and possible types which pass the type condition.",
      requiresSchema: true
    }
  ),
  validationToRule(
    {
      ruleId: "possible-type-extension",
      rule: _indexjs.PossibleTypeExtensionsRule,
      hasDidYouMeanSuggestions: true
    },
    {
      category: "Schema",
      description: "A type extension is only valid if the type is defined and has the same kind.",
      recommended: true,
      requiresSchema: true
    }
  ),
  validationToRule(
    {
      ruleId: "provided-required-arguments",
      rule: _indexjs.ProvidedRequiredArgumentsRule
    },
    {
      category: ["Schema", "Operations"],
      description: "A field or directive is only valid if all required (non-null without a default value) field arguments have been provided.",
      requiresSchema: true
    }
  ),
  validationToRule(
    {
      ruleId: "scalar-leafs",
      rule: _indexjs.ScalarLeafsRule,
      hasDidYouMeanSuggestions: true
    },
    {
      category: "Operations",
      description: "A GraphQL document is valid only if all leaf fields (fields without sub selections) are of scalar or enum types.",
      requiresSchema: true
    }
  ),
  validationToRule(
    {
      ruleId: "one-field-subscriptions",
      rule: _indexjs.SingleFieldSubscriptionsRule
    },
    {
      category: "Operations",
      description: "A GraphQL subscription is valid only if it contains a single root field.",
      requiresSchema: true
    }
  ),
  validationToRule(
    {
      ruleId: "unique-argument-names",
      rule: _indexjs.UniqueArgumentNamesRule
    },
    {
      category: "Operations",
      description: "A GraphQL field or directive is only valid if all supplied arguments are uniquely named.",
      requiresSchema: true
    }
  ),
  validationToRule(
    {
      ruleId: "unique-directive-names",
      rule: _indexjs.UniqueDirectiveNamesRule
    },
    {
      category: "Schema",
      description: "A GraphQL document is only valid if all defined directives have unique names."
    }
  ),
  validationToRule(
    {
      ruleId: "unique-directive-names-per-location",
      rule: _indexjs.UniqueDirectivesPerLocationRule
    },
    {
      category: ["Schema", "Operations"],
      description: "A GraphQL document is only valid if all non-repeatable directives at a given location are uniquely named.",
      requiresSchema: true
    }
  ),
  validationToRule(
    {
      ruleId: "unique-field-definition-names",
      rule: _indexjs.UniqueFieldDefinitionNamesRule
    },
    {
      category: "Schema",
      description: "A GraphQL complex type is only valid if all its fields are uniquely named."
    }
  ),
  validationToRule(
    {
      ruleId: "unique-input-field-names",
      rule: _indexjs.UniqueInputFieldNamesRule
    },
    {
      category: "Operations",
      description: "A GraphQL input object value is only valid if all supplied fields are uniquely named."
    }
  ),
  validationToRule(
    {
      ruleId: "unique-operation-types",
      rule: _indexjs.UniqueOperationTypesRule
    },
    {
      category: "Schema",
      description: "A GraphQL document is only valid if it has only one type per operation."
    }
  ),
  validationToRule(
    {
      ruleId: "unique-type-names",
      rule: _indexjs.UniqueTypeNamesRule
    },
    {
      category: "Schema",
      description: "A GraphQL document is only valid if all defined types have unique names."
    }
  ),
  validationToRule(
    {
      ruleId: "unique-variable-names",
      rule: _indexjs.UniqueVariableNamesRule
    },
    {
      category: "Operations",
      description: "A GraphQL operation is only valid if all its variables are uniquely named.",
      requiresSchema: true
    }
  ),
  validationToRule(
    {
      ruleId: "value-literals-of-correct-type",
      rule: _indexjs.ValuesOfCorrectTypeRule,
      hasDidYouMeanSuggestions: true
    },
    {
      category: "Operations",
      description: "A GraphQL document is only valid if all value literals are of the type expected at their position.",
      requiresSchema: true
    }
  ),
  validationToRule(
    {
      ruleId: "variables-are-input-types",
      rule: _indexjs.VariablesAreInputTypesRule
    },
    {
      category: "Operations",
      description: "A GraphQL operation is only valid if all the variables it defines are of input types (scalar, enum, or input object).",
      requiresSchema: true
    }
  ),
  validationToRule(
    {
      ruleId: "variables-in-allowed-position",
      rule: _indexjs.VariablesInAllowedPositionRule
    },
    {
      category: "Operations",
      description: "Variables passed to field arguments conform to type.",
      requiresSchema: true
    }
  )
);


exports.GRAPHQL_JS_VALIDATIONS = GRAPHQL_JS_VALIDATIONS;
