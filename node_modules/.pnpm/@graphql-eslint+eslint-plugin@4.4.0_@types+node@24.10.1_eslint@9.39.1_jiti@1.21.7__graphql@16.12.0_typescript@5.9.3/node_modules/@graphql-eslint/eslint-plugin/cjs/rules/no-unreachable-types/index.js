"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } function _optionalChain(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }





var _graphql = require('graphql');
var _lodashlowercase = require('lodash.lowercase'); var _lodashlowercase2 = _interopRequireDefault(_lodashlowercase);
var _cachejs = require('../../cache.js');
var _utilsjs = require('../../utils.js');
const RULE_ID = "no-unreachable-types";
const KINDS = [
  _graphql.Kind.DIRECTIVE_DEFINITION,
  _graphql.Kind.OBJECT_TYPE_DEFINITION,
  _graphql.Kind.OBJECT_TYPE_EXTENSION,
  _graphql.Kind.INTERFACE_TYPE_DEFINITION,
  _graphql.Kind.INTERFACE_TYPE_EXTENSION,
  _graphql.Kind.SCALAR_TYPE_DEFINITION,
  _graphql.Kind.SCALAR_TYPE_EXTENSION,
  _graphql.Kind.INPUT_OBJECT_TYPE_DEFINITION,
  _graphql.Kind.INPUT_OBJECT_TYPE_EXTENSION,
  _graphql.Kind.UNION_TYPE_DEFINITION,
  _graphql.Kind.UNION_TYPE_EXTENSION,
  _graphql.Kind.ENUM_TYPE_DEFINITION,
  _graphql.Kind.ENUM_TYPE_EXTENSION
];
const reachableTypesCache = new (0, _cachejs.ModuleCache)();
const RequestDirectiveLocations = /* @__PURE__ */ new Set([
  _graphql.DirectiveLocation.QUERY,
  _graphql.DirectiveLocation.MUTATION,
  _graphql.DirectiveLocation.SUBSCRIPTION,
  _graphql.DirectiveLocation.FIELD,
  _graphql.DirectiveLocation.FRAGMENT_DEFINITION,
  _graphql.DirectiveLocation.FRAGMENT_SPREAD,
  _graphql.DirectiveLocation.INLINE_FRAGMENT,
  _graphql.DirectiveLocation.VARIABLE_DEFINITION
]);
function getReachableTypes(schema) {
  const cachedValue = reachableTypesCache.get(schema);
  if (process.env.NODE_ENV !== "test" && cachedValue) {
    return cachedValue;
  }
  const reachableTypes = /* @__PURE__ */ new Set();
  const collect = (node) => {
    const typeName = _utilsjs.getTypeName.call(void 0, node);
    if (reachableTypes.has(typeName)) {
      return;
    }
    reachableTypes.add(typeName);
    const type = schema.getType(typeName) || schema.getDirective(typeName);
    if (_graphql.isInterfaceType.call(void 0, type)) {
      const { objects, interfaces } = schema.getImplementations(type);
      for (const { astNode } of [...objects, ...interfaces]) {
        _graphql.visit.call(void 0, astNode, visitor);
      }
    } else if (_optionalChain([type, 'optionalAccess', _ => _.astNode])) {
      _graphql.visit.call(void 0, type.astNode, visitor);
    }
  };
  const visitor = {
    InterfaceTypeDefinition: collect,
    ObjectTypeDefinition: collect,
    InputValueDefinition: collect,
    UnionTypeDefinition: collect,
    FieldDefinition: collect,
    Directive: collect,
    NamedType: collect
  };
  for (const type of [
    schema,
    // visiting SchemaDefinition node
    schema.getQueryType(),
    schema.getMutationType(),
    schema.getSubscriptionType()
  ]) {
    if (_optionalChain([type, 'optionalAccess', _2 => _2.astNode])) {
      _graphql.visit.call(void 0, type.astNode, visitor);
    }
  }
  for (const node of schema.getDirectives()) {
    if (node.locations.some((location) => RequestDirectiveLocations.has(location))) {
      reachableTypes.add(node.name);
      for (const arg of node.args) {
        reachableTypes.add(_graphql.getNamedType.call(void 0, arg.type).name);
      }
    }
  }
  reachableTypesCache.set(schema, reachableTypes);
  return reachableTypes;
}
const rule = {
  meta: {
    messages: {
      [RULE_ID]: "{{ type }} `{{ typeName }}` is unreachable."
    },
    docs: {
      description: "Requires all types to be reachable at some level by root level fields.",
      category: "Schema",
      url: `https://the-guild.dev/graphql/eslint/rules/${RULE_ID}`,
      requiresSchema: true,
      examples: [
        {
          title: "Incorrect",
          code: (
            /* GraphQL */
            `
            type User {
              id: ID!
              name: String
            }

            type Query {
              me: String
            }
          `
          )
        },
        {
          title: "Correct",
          code: (
            /* GraphQL */
            `
            type User {
              id: ID!
              name: String
            }

            type Query {
              me: User
            }
          `
          )
        }
      ],
      recommended: true
    },
    type: "suggestion",
    schema: [],
    hasSuggestions: true
  },
  create(context) {
    const schema = _utilsjs.requireGraphQLSchema.call(void 0, RULE_ID, context);
    const reachableTypes = getReachableTypes(schema);
    return {
      [`:matches(${KINDS}) > .name`](node) {
        const typeName = node.value;
        if (!reachableTypes.has(typeName)) {
          const type = _lodashlowercase2.default.call(void 0, node.parent.kind.replace(/(Extension|Definition)$/, ""));
          context.report({
            node,
            messageId: RULE_ID,
            data: {
              type: type[0].toUpperCase() + type.slice(1),
              typeName
            },
            suggest: [
              {
                desc: `Remove \`${typeName}\``,
                fix: (fixer) => fixer.remove(node.parent)
              }
            ]
          });
        }
      }
    };
  }
};


exports.rule = rule;
