import {
  DirectiveLocation,
  getNamedType,
  isInterfaceType,
  Kind,
  visit
} from "graphql";
import lowerCase from "lodash.lowercase";
import { ModuleCache } from "../../cache.js";
import { getTypeName, requireGraphQLSchema } from "../../utils.js";
const RULE_ID = "no-unreachable-types";
const KINDS = [
  Kind.DIRECTIVE_DEFINITION,
  Kind.OBJECT_TYPE_DEFINITION,
  Kind.OBJECT_TYPE_EXTENSION,
  Kind.INTERFACE_TYPE_DEFINITION,
  Kind.INTERFACE_TYPE_EXTENSION,
  Kind.SCALAR_TYPE_DEFINITION,
  Kind.SCALAR_TYPE_EXTENSION,
  Kind.INPUT_OBJECT_TYPE_DEFINITION,
  Kind.INPUT_OBJECT_TYPE_EXTENSION,
  Kind.UNION_TYPE_DEFINITION,
  Kind.UNION_TYPE_EXTENSION,
  Kind.ENUM_TYPE_DEFINITION,
  Kind.ENUM_TYPE_EXTENSION
];
const reachableTypesCache = new ModuleCache();
const RequestDirectiveLocations = /* @__PURE__ */ new Set([
  DirectiveLocation.QUERY,
  DirectiveLocation.MUTATION,
  DirectiveLocation.SUBSCRIPTION,
  DirectiveLocation.FIELD,
  DirectiveLocation.FRAGMENT_DEFINITION,
  DirectiveLocation.FRAGMENT_SPREAD,
  DirectiveLocation.INLINE_FRAGMENT,
  DirectiveLocation.VARIABLE_DEFINITION
]);
function getReachableTypes(schema) {
  const cachedValue = reachableTypesCache.get(schema);
  if (process.env.NODE_ENV !== "test" && cachedValue) {
    return cachedValue;
  }
  const reachableTypes = /* @__PURE__ */ new Set();
  const collect = (node) => {
    const typeName = getTypeName(node);
    if (reachableTypes.has(typeName)) {
      return;
    }
    reachableTypes.add(typeName);
    const type = schema.getType(typeName) || schema.getDirective(typeName);
    if (isInterfaceType(type)) {
      const { objects, interfaces } = schema.getImplementations(type);
      for (const { astNode } of [...objects, ...interfaces]) {
        visit(astNode, visitor);
      }
    } else if (type?.astNode) {
      visit(type.astNode, visitor);
    }
  };
  const visitor = {
    InterfaceTypeDefinition: collect,
    ObjectTypeDefinition: collect,
    InputValueDefinition: collect,
    UnionTypeDefinition: collect,
    FieldDefinition: collect,
    Directive: collect,
    NamedType: collect
  };
  for (const type of [
    schema,
    // visiting SchemaDefinition node
    schema.getQueryType(),
    schema.getMutationType(),
    schema.getSubscriptionType()
  ]) {
    if (type?.astNode) {
      visit(type.astNode, visitor);
    }
  }
  for (const node of schema.getDirectives()) {
    if (node.locations.some((location) => RequestDirectiveLocations.has(location))) {
      reachableTypes.add(node.name);
      for (const arg of node.args) {
        reachableTypes.add(getNamedType(arg.type).name);
      }
    }
  }
  reachableTypesCache.set(schema, reachableTypes);
  return reachableTypes;
}
const rule = {
  meta: {
    messages: {
      [RULE_ID]: "{{ type }} `{{ typeName }}` is unreachable."
    },
    docs: {
      description: "Requires all types to be reachable at some level by root level fields.",
      category: "Schema",
      url: `https://the-guild.dev/graphql/eslint/rules/${RULE_ID}`,
      requiresSchema: true,
      examples: [
        {
          title: "Incorrect",
          code: (
            /* GraphQL */
            `
            type User {
              id: ID!
              name: String
            }

            type Query {
              me: String
            }
          `
          )
        },
        {
          title: "Correct",
          code: (
            /* GraphQL */
            `
            type User {
              id: ID!
              name: String
            }

            type Query {
              me: User
            }
          `
          )
        }
      ],
      recommended: true
    },
    type: "suggestion",
    schema: [],
    hasSuggestions: true
  },
  create(context) {
    const schema = requireGraphQLSchema(RULE_ID, context);
    const reachableTypes = getReachableTypes(schema);
    return {
      [`:matches(${KINDS}) > .name`](node) {
        const typeName = node.value;
        if (!reachableTypes.has(typeName)) {
          const type = lowerCase(node.parent.kind.replace(/(Extension|Definition)$/, ""));
          context.report({
            node,
            messageId: RULE_ID,
            data: {
              type: type[0].toUpperCase() + type.slice(1),
              typeName
            },
            suggest: [
              {
                desc: `Remove \`${typeName}\``,
                fix: (fixer) => fixer.remove(node.parent)
              }
            ]
          });
        }
      }
    };
  }
};
export {
  rule
};
