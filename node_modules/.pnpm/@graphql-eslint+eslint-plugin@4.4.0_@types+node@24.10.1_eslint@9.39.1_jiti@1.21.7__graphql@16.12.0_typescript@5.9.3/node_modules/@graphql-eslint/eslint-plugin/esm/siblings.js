import {
  Kind,
  visit
} from "graphql";
import { logger } from "./utils.js";
const siblingOperationsCache = /* @__PURE__ */ new Map();
function getSiblings(documents) {
  if (documents.length === 0) {
    let printed = false;
    const noopWarn = () => {
      if (!printed) {
        logger.warn(
          "getSiblingOperations was called without any operations. Make sure to set graphql-config `documents` field to make this feature available! See https://the-guild.dev/graphql/config/docs/user/documents for more info"
        );
        printed = true;
      }
      return [];
    };
    return {
      available: false,
      getFragment: noopWarn,
      getFragments: noopWarn,
      getFragmentByType: noopWarn,
      getFragmentsInUse: noopWarn,
      getOperation: noopWarn,
      getOperations: noopWarn,
      getOperationByType: noopWarn
    };
  }
  const value = siblingOperationsCache.get(documents);
  if (value) {
    return value;
  }
  let fragmentsCache = null;
  const getFragments = () => {
    if (fragmentsCache === null) {
      const result = [];
      for (const source of documents) {
        for (const definition of source.document?.definitions || []) {
          if (definition.kind === Kind.FRAGMENT_DEFINITION) {
            result.push({
              filePath: source.location,
              document: definition
            });
          }
        }
      }
      fragmentsCache = result;
    }
    return fragmentsCache;
  };
  let cachedOperations = null;
  const getOperations = () => {
    if (cachedOperations === null) {
      const result = [];
      for (const source of documents) {
        for (const definition of source.document?.definitions || []) {
          if (definition.kind === Kind.OPERATION_DEFINITION) {
            result.push({
              filePath: source.location,
              document: definition
            });
          }
        }
      }
      cachedOperations = result;
    }
    return cachedOperations;
  };
  const getFragment = (name) => getFragments().filter((f) => f.document.name.value === name);
  const collectFragments = (selectable, recursive, collected = /* @__PURE__ */ new Map()) => {
    visit(selectable, {
      FragmentSpread(spread) {
        const fragmentName = spread.name.value;
        const [fragment] = getFragment(fragmentName);
        if (!fragment) {
          logger.warn(
            `Unable to locate fragment named "${fragmentName}", please make sure it's loaded using "parserOptions.operations"`
          );
          return;
        }
        if (!collected.has(fragmentName)) {
          collected.set(fragmentName, fragment.document);
          if (recursive) {
            collectFragments(fragment.document, recursive, collected);
          }
        }
      }
    });
    return collected;
  };
  const siblingOperations = {
    available: true,
    getFragment,
    getFragments,
    getFragmentByType: (typeName) => getFragments().filter((f) => f.document.typeCondition.name.value === typeName),
    getFragmentsInUse: (selectable, recursive = true) => Array.from(collectFragments(selectable, recursive).values()),
    getOperation: (name) => getOperations().filter((o) => o.document.name?.value === name),
    getOperations,
    getOperationByType: (type) => getOperations().filter((o) => o.document.operation === type)
  };
  siblingOperationsCache.set(documents, siblingOperations);
  return siblingOperations;
}
export {
  getSiblings
};
