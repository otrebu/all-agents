{"version":3,"file":"create-route-property-order.utils.js","sources":["../../../../src/rules/create-route-property-order/create-route-property-order.utils.ts"],"sourcesContent":["export function sortDataByOrder<T, TKey extends keyof T>(\n  data: Array<T> | ReadonlyArray<T>,\n  orderRules: ReadonlyArray<\n    Readonly<[ReadonlyArray<T[TKey]>, ReadonlyArray<T[TKey]>]>\n  >,\n  key: TKey,\n): Array<T> | null {\n  const getSubsetIndex = (\n    item: T[TKey],\n    subsets: ReadonlyArray<ReadonlyArray<T[TKey]> | Array<T[TKey]>>,\n  ): number | null => {\n    for (let i = 0; i < subsets.length; i++) {\n      if (subsets[i]?.includes(item)) {\n        return i\n      }\n    }\n    return null\n  }\n\n  const orderSets = orderRules.reduce(\n    (sets, [A, B]) => [...sets, A, B],\n    [] as Array<ReadonlyArray<T[TKey]> | Array<T[TKey]>>,\n  )\n\n  const inOrderArray = data.filter(\n    (item) => getSubsetIndex(item[key], orderSets) !== null,\n  )\n\n  let wasResorted = false as boolean\n\n  // Sort by the relative order defined by the rules\n  const sortedArray = inOrderArray.sort((a, b) => {\n    const aKey = a[key],\n      bKey = b[key]\n    const aSubsetIndex = getSubsetIndex(aKey, orderSets)\n    const bSubsetIndex = getSubsetIndex(bKey, orderSets)\n\n    // If both items belong to different subsets, sort by their subset order\n    if (\n      aSubsetIndex !== null &&\n      bSubsetIndex !== null &&\n      aSubsetIndex !== bSubsetIndex\n    ) {\n      return aSubsetIndex - bSubsetIndex\n    }\n\n    // If both items belong to the same subset or neither is in the subset, keep their relative order\n    return 0\n  })\n\n  const inOrderIterator = sortedArray.values()\n  const result = data.map((item) => {\n    if (getSubsetIndex(item[key], orderSets) !== null) {\n      const sortedItem = inOrderIterator.next().value!\n      if (sortedItem[key] !== item[key]) {\n        wasResorted = true\n      }\n      return sortedItem\n    }\n    return item\n  })\n\n  if (!wasResorted) {\n    return null\n  }\n  return result\n}\n\nexport function getCheckedProperties<T>(\n  orderRules: ReadonlyArray<ReadonlyArray<ReadonlyArray<T>>>,\n): ReadonlyArray<T> {\n  return [...new Set<T>(orderRules.flat(2))]\n}\n"],"names":[],"mappings":"AAAO,SAAS,gBACd,MACA,YAGA,KACiB;AACjB,QAAM,iBAAiB,CACrB,MACA,YACkB;AAClB,aAAS,IAAI,GAAG,IAAI,QAAQ,QAAQ,KAAK;AACvC,UAAI,QAAQ,CAAC,GAAG,SAAS,IAAI,GAAG;AAC9B,eAAO;AAAA,MACT;AAAA,IACF;AACA,WAAO;AAAA,EACT;AAEA,QAAM,YAAY,WAAW;AAAA,IAC3B,CAAC,MAAM,CAAC,GAAG,CAAC,MAAM,CAAC,GAAG,MAAM,GAAG,CAAC;AAAA,IAChC,CAAA;AAAA,EAAC;AAGH,QAAM,eAAe,KAAK;AAAA,IACxB,CAAC,SAAS,eAAe,KAAK,GAAG,GAAG,SAAS,MAAM;AAAA,EAAA;AAGrD,MAAI,cAAc;AAGlB,QAAM,cAAc,aAAa,KAAK,CAAC,GAAG,MAAM;AAC9C,UAAM,OAAO,EAAE,GAAG,GAChB,OAAO,EAAE,GAAG;AACd,UAAM,eAAe,eAAe,MAAM,SAAS;AACnD,UAAM,eAAe,eAAe,MAAM,SAAS;AAGnD,QACE,iBAAiB,QACjB,iBAAiB,QACjB,iBAAiB,cACjB;AACA,aAAO,eAAe;AAAA,IACxB;AAGA,WAAO;AAAA,EACT,CAAC;AAED,QAAM,kBAAkB,YAAY,OAAA;AACpC,QAAM,SAAS,KAAK,IAAI,CAAC,SAAS;AAChC,QAAI,eAAe,KAAK,GAAG,GAAG,SAAS,MAAM,MAAM;AACjD,YAAM,aAAa,gBAAgB,KAAA,EAAO;AAC1C,UAAI,WAAW,GAAG,MAAM,KAAK,GAAG,GAAG;AACjC,sBAAc;AAAA,MAChB;AACA,aAAO;AAAA,IACT;AACA,WAAO;AAAA,EACT,CAAC;AAED,MAAI,CAAC,aAAa;AAChB,WAAO;AAAA,EACT;AACA,SAAO;AACT;AAEO,SAAS,qBACd,YACkB;AAClB,SAAO,CAAC,GAAG,IAAI,IAAO,WAAW,KAAK,CAAC,CAAC,CAAC;AAC3C;"}