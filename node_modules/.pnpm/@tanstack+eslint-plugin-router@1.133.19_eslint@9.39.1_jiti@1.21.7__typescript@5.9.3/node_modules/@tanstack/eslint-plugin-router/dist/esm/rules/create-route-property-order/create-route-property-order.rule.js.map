{"version":3,"file":"create-route-property-order.rule.js","sources":["../../../../src/rules/create-route-property-order/create-route-property-order.rule.ts"],"sourcesContent":["import { AST_NODE_TYPES, ESLintUtils } from '@typescript-eslint/utils'\n\nimport { getDocsUrl } from '../../utils/get-docs-url'\nimport { detectTanstackRouterImports } from '../../utils/detect-router-imports'\nimport { sortDataByOrder } from './create-route-property-order.utils'\nimport {\n  createRouteFunctions,\n  createRouteFunctionsIndirect,\n  sortRules,\n} from './constants'\nimport type { CreateRouteFunction } from './constants'\nimport type { ExtraRuleDocs } from '../../types'\n\nconst createRule = ESLintUtils.RuleCreator<ExtraRuleDocs>(getDocsUrl)\n\nconst createRouteFunctionSet = new Set(createRouteFunctions)\nfunction isCreateRouteFunction(node: any): node is CreateRouteFunction {\n  return createRouteFunctionSet.has(node)\n}\n\nexport const name = 'create-route-property-order'\n\nexport const rule = createRule({\n  name,\n  meta: {\n    type: 'problem',\n    docs: {\n      description:\n        'Ensure correct order of inference sensitive properties for createRoute functions',\n      recommended: 'error',\n    },\n    messages: {\n      invalidOrder: 'Invalid order of properties for `{{function}}`.',\n    },\n    schema: [],\n    hasSuggestions: true,\n    fixable: 'code',\n  },\n  defaultOptions: [],\n\n  create: detectTanstackRouterImports((context) => {\n    return {\n      CallExpression(node) {\n        if (node.callee.type !== AST_NODE_TYPES.Identifier) {\n          return\n        }\n        const createRouteFunction = node.callee.name\n        if (!isCreateRouteFunction(createRouteFunction)) {\n          return\n        }\n        let args = node.arguments\n        if (createRouteFunctionsIndirect.includes(createRouteFunction as any)) {\n          if (node.parent.type === AST_NODE_TYPES.CallExpression) {\n            args = node.parent.arguments\n          } else {\n            return\n          }\n        }\n\n        const argument = args[0]\n        if (argument === undefined || argument.type !== 'ObjectExpression') {\n          return\n        }\n\n        const allProperties = argument.properties\n        // no need to sort if there is at max 1 property\n        if (allProperties.length < 2) {\n          return\n        }\n\n        const properties = allProperties.flatMap((p) => {\n          if (\n            p.type === AST_NODE_TYPES.Property &&\n            p.key.type === AST_NODE_TYPES.Identifier\n          ) {\n            return { name: p.key.name, property: p }\n          } else if (p.type === AST_NODE_TYPES.SpreadElement) {\n            if (p.argument.type === AST_NODE_TYPES.Identifier) {\n              return { name: p.argument.name, property: p }\n            } else {\n              throw new Error('Unsupported spread element')\n            }\n          }\n          return []\n        })\n\n        const sortedProperties = sortDataByOrder(properties, sortRules, 'name')\n        if (sortedProperties === null) {\n          return\n        }\n        context.report({\n          node: argument,\n          data: { function: node.callee.name },\n          messageId: 'invalidOrder',\n          fix(fixer) {\n            const sourceCode = context.sourceCode\n\n            const text = sortedProperties.reduce(\n              (sourceText, specifier, index) => {\n                let text = ''\n                if (index < allProperties.length - 1) {\n                  text = sourceCode\n                    .getText()\n                    .slice(\n                      allProperties[index]!.range[1],\n                      allProperties[index + 1]!.range[0],\n                    )\n                }\n                return (\n                  sourceText + sourceCode.getText(specifier.property) + text\n                )\n              },\n              '',\n            )\n            return fixer.replaceTextRange(\n              [allProperties[0]!.range[0], allProperties.at(-1)!.range[1]],\n              text,\n            )\n          },\n        })\n      },\n    }\n  }),\n})\n"],"names":["text"],"mappings":";;;;;AAaA,MAAM,aAAa,YAAY,YAA2B,UAAU;AAEpE,MAAM,yBAAyB,IAAI,IAAI,oBAAoB;AAC3D,SAAS,sBAAsB,MAAwC;AACrE,SAAO,uBAAuB,IAAI,IAAI;AACxC;AAEO,MAAM,OAAO;AAEb,MAAM,OAAO,WAAW;AAAA,EAC7B;AAAA,EACA,MAAM;AAAA,IACJ,MAAM;AAAA,IACN,MAAM;AAAA,MACJ,aACE;AAAA,MACF,aAAa;AAAA,IAAA;AAAA,IAEf,UAAU;AAAA,MACR,cAAc;AAAA,IAAA;AAAA,IAEhB,QAAQ,CAAA;AAAA,IACR,gBAAgB;AAAA,IAChB,SAAS;AAAA,EAAA;AAAA,EAEX,gBAAgB,CAAA;AAAA,EAEhB,QAAQ,4BAA4B,CAAC,YAAY;AAC/C,WAAO;AAAA,MACL,eAAe,MAAM;AACnB,YAAI,KAAK,OAAO,SAAS,eAAe,YAAY;AAClD;AAAA,QACF;AACA,cAAM,sBAAsB,KAAK,OAAO;AACxC,YAAI,CAAC,sBAAsB,mBAAmB,GAAG;AAC/C;AAAA,QACF;AACA,YAAI,OAAO,KAAK;AAChB,YAAI,6BAA6B,SAAS,mBAA0B,GAAG;AACrE,cAAI,KAAK,OAAO,SAAS,eAAe,gBAAgB;AACtD,mBAAO,KAAK,OAAO;AAAA,UACrB,OAAO;AACL;AAAA,UACF;AAAA,QACF;AAEA,cAAM,WAAW,KAAK,CAAC;AACvB,YAAI,aAAa,UAAa,SAAS,SAAS,oBAAoB;AAClE;AAAA,QACF;AAEA,cAAM,gBAAgB,SAAS;AAE/B,YAAI,cAAc,SAAS,GAAG;AAC5B;AAAA,QACF;AAEA,cAAM,aAAa,cAAc,QAAQ,CAAC,MAAM;AAC9C,cACE,EAAE,SAAS,eAAe,YAC1B,EAAE,IAAI,SAAS,eAAe,YAC9B;AACA,mBAAO,EAAE,MAAM,EAAE,IAAI,MAAM,UAAU,EAAA;AAAA,UACvC,WAAW,EAAE,SAAS,eAAe,eAAe;AAClD,gBAAI,EAAE,SAAS,SAAS,eAAe,YAAY;AACjD,qBAAO,EAAE,MAAM,EAAE,SAAS,MAAM,UAAU,EAAA;AAAA,YAC5C,OAAO;AACL,oBAAM,IAAI,MAAM,4BAA4B;AAAA,YAC9C;AAAA,UACF;AACA,iBAAO,CAAA;AAAA,QACT,CAAC;AAED,cAAM,mBAAmB,gBAAgB,YAAY,WAAW,MAAM;AACtE,YAAI,qBAAqB,MAAM;AAC7B;AAAA,QACF;AACA,gBAAQ,OAAO;AAAA,UACb,MAAM;AAAA,UACN,MAAM,EAAE,UAAU,KAAK,OAAO,KAAA;AAAA,UAC9B,WAAW;AAAA,UACX,IAAI,OAAO;AACT,kBAAM,aAAa,QAAQ;AAE3B,kBAAM,OAAO,iBAAiB;AAAA,cAC5B,CAAC,YAAY,WAAW,UAAU;AAChC,oBAAIA,QAAO;AACX,oBAAI,QAAQ,cAAc,SAAS,GAAG;AACpCA,0BAAO,WACJ,QAAA,EACA;AAAA,oBACC,cAAc,KAAK,EAAG,MAAM,CAAC;AAAA,oBAC7B,cAAc,QAAQ,CAAC,EAAG,MAAM,CAAC;AAAA,kBAAA;AAAA,gBAEvC;AACA,uBACE,aAAa,WAAW,QAAQ,UAAU,QAAQ,IAAIA;AAAAA,cAE1D;AAAA,cACA;AAAA,YAAA;AAEF,mBAAO,MAAM;AAAA,cACX,CAAC,cAAc,CAAC,EAAG,MAAM,CAAC,GAAG,cAAc,GAAG,EAAE,EAAG,MAAM,CAAC,CAAC;AAAA,cAC3D;AAAA,YAAA;AAAA,UAEJ;AAAA,QAAA,CACD;AAAA,MACH;AAAA,IAAA;AAAA,EAEJ,CAAC;AACH,CAAC;"}