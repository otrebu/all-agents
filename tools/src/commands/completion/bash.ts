/**
 * Bash completion script generator for aaa CLI
 *
 * Features:
 * - Self-contained (no _init_completion dependency)
 * - While-loop to find subcommand chain (skips flags)
 * - $prev check for flag value completion (highest priority)
 * - Dynamic completions via `<invoked-command> __complete <type>`
 * - Falls back to file completion via -o bashdefault -o default
 */
export default function generateBashCompletion(): string {
  return `# aaa bash completion
# Generated by: aaa completion bash
# Install: source <(aaa completion bash)
# Or add to ~/.bashrc: source <(aaa completion bash)

_aaa_completions() {
    local cur prev
    cur="\${COMP_WORDS[COMP_CWORD]}"
    prev="\${COMP_WORDS[COMP_CWORD-1]}"
    local completion_cmd="\${COMP_WORDS[0]}"
    if [[ -z "$completion_cmd" ]]; then
        completion_cmd="aaa"
    fi

    _aaa_complete() {
        "$completion_cmd" __complete "$@" 2>/dev/null
    }

    # PHASE 1: Flag value completion (highest priority)
    case "$prev" in
        --mode)
            COMPREPLY=($(compgen -W "quick deep code" -- "$cur"))
            return
            ;;
        --processor)
            COMPREPLY=($(compgen -W "base pro" -- "$cur"))
            return
            ;;
        --milestone)
            # Dynamic milestone names + directory completion fallback
            local milestones=$(_aaa_complete milestone)
            COMPREPLY=($(compgen -W "$milestones" -- "$cur"))
            # Also add directory completion
            COMPREPLY+=($(compgen -d -- "$cur"))
            return
            ;;
        --output-dir)
            # Milestone names or directories
            local output_dirs=$(_aaa_complete milestone)
            COMPREPLY=($(compgen -W "$output_dirs" -- "$cur"))
            COMPREPLY+=($(compgen -d -- "$cur"))
            return
            ;;
        --story)
            # Dynamic story names + file completion fallback
            local stories=$(_aaa_complete story)
            COMPREPLY=($(compgen -W "$stories" -- "$cur"))
            # Also add .md file completion
            COMPREPLY+=($(compgen -f -X '!*.md' -- "$cur"))
            return
            ;;
        --task)
            # Dynamic task names + file completion fallback
            local tasks=$(_aaa_complete task)
            COMPREPLY=($(compgen -W "$tasks" -- "$cur"))
            # Also add .md file completion
            COMPREPLY+=($(compgen -f -X '!*.md' -- "$cur"))
            return
            ;;
        --file)
            # Generic file path completion
            COMPREPLY=($(compgen -f -- "$cur"))
            return
            ;;
        --subtasks)
            # Complete .json files
            COMPREPLY=($(compgen -f -X '!*.json' -- "$cur"))
            return
            ;;
        --size)
            COMPREPLY=($(compgen -W "small medium large" -- "$cur"))
            return
            ;;
        --cascade)
            # Dynamic cascade targets
            local targets=$(_aaa_complete cascade)
            COMPREPLY=($(compgen -W "$targets" -- "$cur"))
            return
            ;;
        --provider)
            # Dynamic provider names
            local providers=$(_aaa_complete provider)
            COMPREPLY=($(compgen -W "$providers" -- "$cur"))
            return
            ;;
        --id)
            # Dynamic session IDs
            local session_ids=$(_aaa_complete session-id)
            COMPREPLY=($(compgen -W "$session_ids" -- "$cur"))
            return
            ;;
        --model)
            # Dynamic model names, filtered by --provider if present
            local model_args="model"
            local j=1
            while [[ $j -lt $COMP_CWORD ]]; do
                local provider_word="\${COMP_WORDS[j]}"
                if [[ "$provider_word" == "--provider" && $((j+1)) -lt $COMP_CWORD ]]; then
                    model_args="model --provider \${COMP_WORDS[j+1]}"
                    break
                elif [[ "$provider_word" == --provider=* ]]; then
                    local provider_value="\${provider_word#--provider=}"
                    if [[ -n "$provider_value" ]]; then
                        model_args="model --provider $provider_value"
                        break
                    fi
                fi
                ((j++))
            done
            local models=$(_aaa_complete $model_args | cut -f1)
            COMPREPLY=($(compgen -W "$models" -- "$cur"))
            return
            ;;
        --calibrate-every)
            # Numeric values - no completion
            return
            ;;
        -o|--output)
            # File path completion
            COMPREPLY=($(compgen -f -- "$cur"))
            return
            ;;
        -d|--dir)
            # Directory completion
            COMPREPLY=($(compgen -d -- "$cur"))
            return
            ;;
        -t|--target)
            # Directory completion
            COMPREPLY=($(compgen -d -- "$cur"))
            return
            ;;
        --worktree)
            # Directory completion
            COMPREPLY=($(compgen -d -- "$cur"))
            return
            ;;
        -l|--limit|-s|--skip|--max-results|--max-chars|--max-iterations)
            # Numeric values - no completion
            return
            ;;
        --objective|--queries)
            # Free text - no completion
            return
            ;;
        --priority)
            COMPREPLY=($(compgen -W "min low default high max" -- "$cur"))
            return
            ;;
        --quiet-enabled)
            COMPREPLY=($(compgen -W "true false" -- "$cur"))
            return
            ;;
        --format)
            COMPREPLY=($(compgen -W "markdown json" -- "$cur"))
            return
            ;;
    esac

    # PHASE 2: Find subcommand chain (skip flags and their values)
    local cmd="" subcmd="" subsubcmd=""
    local i=1
    local skip_next=false
    while [[ $i -lt $COMP_CWORD ]]; do
        local word="\${COMP_WORDS[i]}"
        if [[ "$skip_next" == "true" ]]; then
            skip_next=false
            ((i++))
            continue
        fi
        case "$word" in
            --mode|--processor|--milestone|--output-dir|--story|--task|--file|--text|--from|--subtasks|--size|--cascade|--calibrate-every|--provider|--model|--id|--commit|--session|--at|--objective|--queries|--stories-directory|--priority|--quiet-enabled|--format|-o|--output|-d|--dir|-t|--target|-l|--limit|-s|--skip|--max-results|--max-chars|--max-iterations)
                # Flag that takes a value - skip next word
                skip_next=true
                ;;
            -*)
                # Other flags (boolean) - skip
                ;;
            *)
                if [[ -z "$cmd" ]]; then
                    cmd="$word"
                elif [[ -z "$subcmd" ]]; then
                    subcmd="$word"
                elif [[ -z "$subsubcmd" ]]; then
                    subsubcmd="$word"
                fi
                ;;
        esac
        ((i++))
    done

    # PHASE 3: Complete flags if typing a dash
    if [[ "$cur" == -* ]]; then
        case "$cmd" in
            extract-conversations)
                COMPREPLY=($(compgen -W "-l --limit -o --output -s --skip" -- "$cur"))
                return
                ;;
            gemini-research)
                COMPREPLY=($(compgen -W "--mode" -- "$cur"))
                return
                ;;
            parallel-search)
                COMPREPLY=($(compgen -W "--objective --queries --processor --max-results --max-chars -v --verbose" -- "$cur"))
                return
                ;;
            setup)
                COMPREPLY=($(compgen -W "--user --project --worktree" -- "$cur"))
                return
                ;;
            uninstall)
                COMPREPLY=($(compgen -W "--user --project" -- "$cur"))
                return
                ;;
            sync-context)
                COMPREPLY=($(compgen -W "-t --target -w --watch" -- "$cur"))
                return
                ;;
            task)
                if [[ "$subcmd" == "create" ]]; then
                    COMPREPLY=($(compgen -W "-d --dir -s --story -m --milestone" -- "$cur"))
                fi
                return
                ;;
            story)
                if [[ "$subcmd" == "create" ]]; then
                    COMPREPLY=($(compgen -W "-d --dir -m --milestone" -- "$cur"))
                fi
                return
                ;;
            ralph)
                case "$subcmd" in
                    build)
                        COMPREPLY=($(compgen -W "--subtasks -p --print -i --interactive -s --supervised -H --headless -q --quiet -S --skip-summary --max-iterations --validate-first --cascade --calibrate-every --force --review --from --provider --model" -- "$cur"))
                        return
                        ;;
                    plan)
                        case "$subsubcmd" in
                            vision)
                                COMPREPLY=($(compgen -W "--provider --model" -- "$cur"))
                                return
                                ;;
                            roadmap)
                                COMPREPLY=($(compgen -W "--force --review --from --cascade --provider --model" -- "$cur"))
                                return
                                ;;
                            stories)
                                COMPREPLY=($(compgen -W "--milestone -s --supervised -H --headless --force --review --from --provider --model --with-reviews --cascade" -- "$cur"))
                                return
                                ;;
                            tasks)
                                COMPREPLY=($(compgen -W "--story --milestone --file --text -s --supervised -H --headless --force --review --from --provider --model --with-reviews --cascade" -- "$cur"))
                                return
                                ;;
                            subtasks)
                                COMPREPLY=($(compgen -W "--force --review --review-diary --from --task --story --milestone --output-dir --size -s --supervised -H --headless --with-reviews --cascade --calibrate-every --validate-first --provider --model --file --text" -- "$cur"))
                                return
                                ;;
                        esac
                        ;;
                    milestones)
                        COMPREPLY=($(compgen -W "--json" -- "$cur"))
                        return
                        ;;
                    models)
                        COMPREPLY=($(compgen -W "--provider --json" -- "$cur"))
                        return
                        ;;
                    status)
                        COMPREPLY=($(compgen -W "--subtasks" -- "$cur"))
                        return
                        ;;
                    subtasks)
                        case "$subsubcmd" in
                            next)
                                COMPREPLY=($(compgen -W "--milestone --json" -- "$cur"))
                                ;;
                            list)
                                COMPREPLY=($(compgen -W "--milestone --pending --limit --json" -- "$cur"))
                                ;;
                            complete)
                                COMPREPLY=($(compgen -W "--milestone --id --commit --session --at" -- "$cur"))
                                ;;
                            *)
                                COMPREPLY=($(compgen -W "next list complete" -- "$cur"))
                                ;;
                        esac
                        return
                        ;;
                    calibrate)
                        COMPREPLY=($(compgen -W "--force --review" -- "$cur"))
                        return
                        ;;
                    review)
                        case "$subsubcmd" in
                            roadmap)
                                COMPREPLY=($(compgen -W "-s --supervised -H --headless --provider --model --dry-run" -- "$cur"))
                                ;;
                            subtasks)
                                COMPREPLY=($(compgen -W "--subtasks -s --supervised -H --headless --provider --model --dry-run" -- "$cur"))
                                ;;
                            tasks)
                                COMPREPLY=($(compgen -W "--story -s --supervised -H --headless --provider --model --dry-run" -- "$cur"))
                                ;;
                            stories)
                                COMPREPLY=($(compgen -W "--milestone -s --supervised -H --headless --provider --model --dry-run" -- "$cur"))
                                ;;
                            gap)
                                COMPREPLY=($(compgen -W "roadmap stories tasks subtasks" -- "$cur"))
                                ;;
                        esac
                        return
                        ;;
                    refresh-models)
                        COMPREPLY=($(compgen -W "--dry-run --prune --provider" -- "$cur"))
                        return
                        ;;
                    archive)
                        if [[ "$subsubcmd" == "subtasks" ]]; then
                            COMPREPLY=($(compgen -W "--subtasks --milestone" -- "$cur"))
                        elif [[ "$subsubcmd" == "progress" ]]; then
                            COMPREPLY=($(compgen -W "--progress" -- "$cur"))
                        fi
                        return
                        ;;
                esac
                ;;
            review)
                if [[ -z "$subcmd" ]]; then
                    COMPREPLY=($(compgen -W "-s --supervised -H --headless --dry-run --require-approval --base --range --staged-only --unstaged-only --provider --model" -- "$cur"))
                fi
                return
                ;;
            session)
                case "$subcmd" in
                    path|cat)
                        COMPREPLY=($(compgen -W "--commit --id" -- "$cur"))
                        ;;
                    list)
                        COMPREPLY=($(compgen -W "--limit --verbose" -- "$cur"))
                        ;;
                esac
                return
                ;;
            notify)
                if [[ -z "$subcmd" ]]; then
                    COMPREPLY=($(compgen -W "-t --title -p --priority --tags -q --quiet --dry-run --event" -- "$cur"))
                elif [[ "$subcmd" == "config" ]]; then
                    case "$subsubcmd" in
                        set)
                            COMPREPLY=($(compgen -W "--topic --server --title --priority --quiet-start --quiet-end --quiet-enabled" -- "$cur"))
                            ;;
                        show)
                            COMPREPLY=($(compgen -W "--json" -- "$cur"))
                            ;;
                        test)
                            COMPREPLY=($(compgen -W "-m --message" -- "$cur"))
                            ;;
                    esac
                fi
                return
                ;;
        esac
        # Global flags
        COMPREPLY=($(compgen -W "-h --help -V --version" -- "$cur"))
        return
    fi

    # PHASE 4: Command/subcommand completion
    case "$cmd" in
        "")
            # Top-level commands
            COMPREPLY=($(compgen -W "extract-conversations gh-search gemini-research notify parallel-search session setup uninstall sync-context task story ralph review completion" -- "$cur"))
            ;;
        task)
            if [[ -z "$subcmd" ]]; then
                COMPREPLY=($(compgen -W "create" -- "$cur"))
            fi
            ;;
        story)
            if [[ -z "$subcmd" ]]; then
                COMPREPLY=($(compgen -W "create" -- "$cur"))
            fi
            ;;
        ralph)
            if [[ -z "$subcmd" ]]; then
                COMPREPLY=($(compgen -W "build plan review milestones models status subtasks calibrate archive refresh-models" -- "$cur"))
            elif [[ "$subcmd" == "plan" && -z "$subsubcmd" ]]; then
                COMPREPLY=($(compgen -W "vision roadmap stories tasks subtasks" -- "$cur"))
            elif [[ "$subcmd" == "review" && -z "$subsubcmd" ]]; then
                COMPREPLY=($(compgen -W "stories roadmap gap tasks subtasks" -- "$cur"))
            elif [[ "$subcmd" == "review" && "$subsubcmd" == "gap" ]]; then
                # ralph review gap subcommands
                COMPREPLY=($(compgen -W "roadmap stories tasks subtasks" -- "$cur"))
            elif [[ "$subcmd" == "subtasks" && -z "$subsubcmd" ]]; then
                COMPREPLY=($(compgen -W "next list complete" -- "$cur"))
            elif [[ "$subcmd" == "calibrate" && -z "$subsubcmd" ]]; then
                COMPREPLY=($(compgen -W "intention technical improve all" -- "$cur"))
            elif [[ "$subcmd" == "archive" && -z "$subsubcmd" ]]; then
                COMPREPLY=($(compgen -W "subtasks progress" -- "$cur"))
            fi
            ;;
        review)
            if [[ -z "$subcmd" ]]; then
                COMPREPLY=($(compgen -W "status" -- "$cur"))
            fi
            ;;
        notify)
            if [[ -z "$subcmd" ]]; then
                COMPREPLY=($(compgen -W "init on off status config" -- "$cur"))
            elif [[ "$subcmd" == "config" && -z "$subsubcmd" ]]; then
                COMPREPLY=($(compgen -W "set show test" -- "$cur"))
            fi
            ;;
        completion)
            if [[ -z "$subcmd" ]]; then
                COMPREPLY=($(compgen -W "bash zsh fish table" -- "$cur"))
            elif [[ "$subcmd" == "table" ]]; then
                COMPREPLY=($(compgen -W "--format" -- "$cur"))
            fi
            ;;
        session)
            if [[ -z "$subcmd" ]]; then
                COMPREPLY=($(compgen -W "path current cat list" -- "$cur"))
            fi
            ;;
    esac
}

complete -o bashdefault -o default -F _aaa_completions aaa
`;
}
